{"ast":null,"code":"import React,{memo}from\"react\";// import { useSelector } from 'react-redux';\nimport\"./message.css\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";function Message(_ref){var uIdFrom=_ref.uIdFrom,msgText=_ref.msgText,uId=_ref.uId,time=_ref.time;//console.log(time);\n// Going to be explicitly converting all time related strings to int instead of relying on implicit conversions and then possibly banging my head later\n// const offsetHours = offset.slice(0, 2); //offset is going to be 0530, as an example for GMT India, taking the hours out of it here - 05\n// const offsetMins = offset.slice(2, 4);  // Taking the minutes out of it here, 30\n// function formatTime(t) {\n//     const timeSplit = t.split(\":\") // t/time for ex is 20:15:48\n//     const offedMins = parseInt(timeSplit[1], 10) + parseInt(offsetMins, 10); // adding the original minutes with offset mins to get regional minutes\n//     const offedHours = parseInt(timeSplit[0], 10) + parseInt(offsetHours, 10);\n//     const parsedHours = offedHours > 12 ? offedHours / 12 : offedHours // adding the og hours with offset hours, and dividing by 12\n//     //console.log(parsedHours, offedHours);\n//     let meridiem = \"AM\";\n//     if ( offedHours > 12) meridiem = \"PM\";\n//     if (offedMins > 60) {\n//         const parsedMins = Math.floor(offedMins / 60).toString();\n//         if (parsedMins.length === 1) {\n//             return `${parsedHours}:${parsedMins.padStart(2, 0)} ${meridiem}`;\n//         }\n//         return `${parsedHours}:${Math.floor(offedMins/60)} ${meridiem}`;\n//     }\n//     return `${parsedHours}:${offedMins} ${meridiem}`;\n//     // if (parseInt(timeSplit[0], 10) > 12) { // if the\n//     //     if (mins > 60) {\n//     //         const parsedMins = Math.floor(mins / 60).toString();\n//     //         if (parsedMins.length === 1) {\n//     //             return `${parsedHours}:${parsedMins.padStart(2, 0)} PM`;\n//     //         }\n//     //         return `${parsedHours}:${Math.floor(mins/60)} PM`;\n//     //     }\n//     //     return `${parsedHours}:${mins} PM`;\n//     // }\n//     // else {\n//     //     if (mins > 60) {\n//     //         const parsedMins = Math.floor(mins / 60).toString();\n//     //         if (parsedMins.length === 1) {\n//     //             return `${parsedHours}:${parsedMins.padStart(2, 0)} AM`;\n//     //         }\n//     //     }\n//     //     return `${parsedHours}:${mins} AM`;\n//     // };\n// };\n// Forget everything above I changed the backend itself. I send the users's timezone every time they login and store it, and use that\n// whenever I need to query something that involves time. A couple more hours of this crap of manipulating dates in javascript and I would've gone bald\n// Why the hell doesn't the contructor new Date(message.date) convert the supplied timestamp to the users's timezone?!?!?!\nreturn/*#__PURE__*/_jsxs(\"div\",{className:\"msg-ctn \".concat(uIdFrom===uId?\"sent-msg\":\"rcvd-msg\"),children:[/*#__PURE__*/_jsx(\"p\",{children:msgText}),/*#__PURE__*/_jsx(\"p\",{children:time})]});}export default/*#__PURE__*/memo(Message);//const msgTimeDetails = new Date(message.date).toLocaleString(\"default\", { dateStyle: \"full\" }); // msgTimeDetails format is Saturday, 12 April, 2022\n//console.log(\"msgTimeDetails\", msgTimeDetails);\n//console.log(msgTimeDetails.split(\" \").slice(1)); //extracting time as 12 April, 2022\n// let date;\n// let msgTime = new Date(message.date).toUTCString().split(\" \")[4]\n// date = msgTime.split(\":\")\n// // if (parseInt(date[0]) > 12) {\n// //     date[0] = (parseInt(date[0]) - 12).toString();\n// //     date = (date[0] + \":\" + date[1])\n// // };\n// //const msgDate = new Date(message.date).toUTCString().split(\" \").slice(1, 4)\n// //console.log(msgDate.join(\" \"));\n// const msgDate = msgTimeDetails.split(\" \").slice(1);\n// useEffect(() => {\n//     if (chatSectionDateRef.current !== msgDate.join(\"  \")) {\n//         setChatSectionDate({ date: msgDate.join(\" \"), display:\n//         true });\n//         chatSectionDateRef.current = msgDate.join(\" \");\n//         //chatSectionDate.current = { date: msgDate.join(\" \"), display: true }\n//         //console.log(\"true\", chatSectionDate, msgDate.join(\" \"));\n//     }\n//     else {\n//         setChatSectionDate({ ...chatSectionDate.date, display: false });\n//         //chatSectionDate.current = { ...chatSectionDate.current, display: false }\n//         console.log(\"false\");\n//     }\n//     // console.log(new Date(message.date).toLocaleDateString(\"default\", { dateStyle: \"full\"}).split(\" \"));\n// }, []);","map":{"version":3,"sources":["/home/runner/work/socioProj/socioProj/src/components/Message/Message.js"],"names":["React","memo","Message","uIdFrom","msgText","uId","time"],"mappings":"AAAA,MAAOA,CAAAA,KAAP,EAAgBC,IAAhB,KAA4B,OAA5B,CACA;AACA,MAAO,eAAP,C,wFAEA,QAASC,CAAAA,OAAT,MAAkD,IAA/BC,CAAAA,OAA+B,MAA/BA,OAA+B,CAAtBC,OAAsB,MAAtBA,OAAsB,CAAbC,GAAa,MAAbA,GAAa,CAARC,IAAQ,MAARA,IAAQ,CACjD;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA,mBACC,aACC,SAAS,mBAAcH,OAAO,GAAKE,GAAZ,CACtB,UADsB,CACT,UADL,CADV,wBAGC,mBAEED,OAFF,EAHD,cAQC,mBAEEE,IAFF,EARD,GADD,CAgBA,CAED,2BAAeL,IAAI,CAACC,OAAD,CAAnB,CAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import React, { memo } from \"react\";\n// import { useSelector } from 'react-redux';\nimport \"./message.css\";\n\nfunction Message({ uIdFrom, msgText, uId, time }) {\n\t//console.log(time);\n\t// Going to be explicitly converting all time related strings to int instead of relying on implicit conversions and then possibly banging my head later\n\t// const offsetHours = offset.slice(0, 2); //offset is going to be 0530, as an example for GMT India, taking the hours out of it here - 05\n\t// const offsetMins = offset.slice(2, 4);  // Taking the minutes out of it here, 30\n\n\t// function formatTime(t) {\n\t//     const timeSplit = t.split(\":\") // t/time for ex is 20:15:48\n\n\t//     const offedMins = parseInt(timeSplit[1], 10) + parseInt(offsetMins, 10); // adding the original minutes with offset mins to get regional minutes\n\t//     const offedHours = parseInt(timeSplit[0], 10) + parseInt(offsetHours, 10);\n\t//     const parsedHours = offedHours > 12 ? offedHours / 12 : offedHours // adding the og hours with offset hours, and dividing by 12\n\n\n\t//     //console.log(parsedHours, offedHours);\n\n\t//     let meridiem = \"AM\";\n\n\t//     if ( offedHours > 12) meridiem = \"PM\";\n\n\t//     if (offedMins > 60) {\n\t//         const parsedMins = Math.floor(offedMins / 60).toString();\n\t//         if (parsedMins.length === 1) {\n\t//             return `${parsedHours}:${parsedMins.padStart(2, 0)} ${meridiem}`;\n\t//         }\n\t//         return `${parsedHours}:${Math.floor(offedMins/60)} ${meridiem}`;\n\t//     }\n\t//     return `${parsedHours}:${offedMins} ${meridiem}`;\n\n\t//     // if (parseInt(timeSplit[0], 10) > 12) { // if the\n\n\t//     //     if (mins > 60) {\n\t//     //         const parsedMins = Math.floor(mins / 60).toString();\n\t//     //         if (parsedMins.length === 1) {\n\t//     //             return `${parsedHours}:${parsedMins.padStart(2, 0)} PM`;\n\t//     //         }\n\t//     //         return `${parsedHours}:${Math.floor(mins/60)} PM`;\n\t//     //     }\n\t//     //     return `${parsedHours}:${mins} PM`;\n\t//     // }\n\t//     // else {\n\t//     //     if (mins > 60) {\n\t//     //         const parsedMins = Math.floor(mins / 60).toString();\n\n\t//     //         if (parsedMins.length === 1) {\n\t//     //             return `${parsedHours}:${parsedMins.padStart(2, 0)} AM`;\n\t//     //         }\n\t//     //     }\n\t//     //     return `${parsedHours}:${mins} AM`;\n\t//     // };\n\t// };\n\n\t// Forget everything above I changed the backend itself. I send the users's timezone every time they login and store it, and use that\n\t// whenever I need to query something that involves time. A couple more hours of this crap of manipulating dates in javascript and I would've gone bald\n\t// Why the hell doesn't the contructor new Date(message.date) convert the supplied timestamp to the users's timezone?!?!?!\n\n\treturn (\n\t\t<div\n\t\t\tclassName={`msg-ctn ${ uIdFrom === uId ?\n\t\t\t\t\"sent-msg\" : \"rcvd-msg\" }`}>\n\t\t\t<p>\n\t\t\t\t{\n\t\t\t\t\tmsgText\n\t\t\t\t}\n\t\t\t</p>\n\t\t\t<p>\n\t\t\t\t{\n\t\t\t\t\ttime\n\t\t\t\t}\n\t\t\t</p>\n\t\t</div>\n\t);\n}\n\nexport default memo(Message);\n\n\n//const msgTimeDetails = new Date(message.date).toLocaleString(\"default\", { dateStyle: \"full\" }); // msgTimeDetails format is Saturday, 12 April, 2022\n//console.log(\"msgTimeDetails\", msgTimeDetails);\n//console.log(msgTimeDetails.split(\" \").slice(1)); //extracting time as 12 April, 2022\n\n// let date;\n// let msgTime = new Date(message.date).toUTCString().split(\" \")[4]\n\n// date = msgTime.split(\":\")\n// // if (parseInt(date[0]) > 12) {\n// //     date[0] = (parseInt(date[0]) - 12).toString();\n// //     date = (date[0] + \":\" + date[1])\n// // };\n// //const msgDate = new Date(message.date).toUTCString().split(\" \").slice(1, 4)\n// //console.log(msgDate.join(\" \"));\n\n// const msgDate = msgTimeDetails.split(\" \").slice(1);\n\n// useEffect(() => {\n//     if (chatSectionDateRef.current !== msgDate.join(\"  \")) {\n//         setChatSectionDate({ date: msgDate.join(\" \"), display:\n//         true });\n//         chatSectionDateRef.current = msgDate.join(\" \");\n//         //chatSectionDate.current = { date: msgDate.join(\" \"), display: true }\n//         //console.log(\"true\", chatSectionDate, msgDate.join(\" \"));\n//     }\n//     else {\n//         setChatSectionDate({ ...chatSectionDate.date, display: false });\n//         //chatSectionDate.current = { ...chatSectionDate.current, display: false }\n//         console.log(\"false\");\n//     }\n//     // console.log(new Date(message.date).toLocaleDateString(\"default\", { dateStyle: \"full\"}).split(\" \"));\n// }, []);\n"]},"metadata":{},"sourceType":"module"}